diff --git a/drivers/tty/vt/selection.c b/drivers/tty/vt/selection.c
index 8967c3a..9be3363 100644
--- a/drivers/tty/vt/selection.c
+++ b/drivers/tty/vt/selection.c
@@ -221,6 +221,8 @@ static int vc_selection_store_chars(struct vc_data *vc, bool unicode)
 			}
 			obp = bp;
 		}
+		if (c > 0x80)
+			i += 2;
 	}
 	vc_sel.buf_len = bp - vc_sel.buffer;
 
diff --git a/drivers/tty/vt/vt.c b/drivers/tty/vt/vt.c
index 5c47f77..6d95968 100644
--- a/drivers/tty/vt/vt.c
+++ b/drivers/tty/vt/vt.c
@@ -300,6 +300,20 @@ static inline unsigned short *screenpos(const struct vc_data *vc, int offset,
 	return p;
 }
 
+static inline unsigned short *screenpos_utf8(const struct vc_data *vc, int offset,
+		bool viewed)
+{
+	unsigned short *p;
+
+	if (!viewed)
+		p = (unsigned short *)(vc->vc_origin + offset + vc->vc_screenbuf_size);
+	else if (!vc->vc_sw->con_screen_pos)
+		p = (unsigned short *)(vc->vc_visible_origin + offset + vc->vc_screenbuf_size);
+	else
+		p = vc->vc_sw->con_screen_pos(vc, -offset - 1);
+	return p;
+}
+
 /* Called  from the keyboard irq path.. */
 static inline void scrolldelta(int lines)
 {
@@ -586,6 +600,10 @@ static void con_scroll(struct vc_data *vc, unsigned int top,
 	}
 	scr_memmovew(dst, src, (rows - nr) * vc->vc_size_row);
 	scr_memsetw(clear, vc->vc_video_erase_char, vc->vc_size_row * nr);
+	dst += (vc->vc_screenbuf_size >> 1);
+	src += (vc->vc_screenbuf_size >> 1);
+	scr_memmovew(dst, src, (rows - nr) * vc->vc_size_row);
+	scr_memsetw(clear, 0, vc->vc_size_row * nr);
 }
 
 static void do_update_region(struct vc_data *vc, unsigned long start, int count)
@@ -754,6 +772,7 @@ void complement_pos(struct vc_data *vc, int offset)
 {
 	static int old_offset = -1;
 	static unsigned short old;
+	static unsigned short old_utf;
 	static unsigned short oldx, oldy;
 
 	WARN_CONSOLE_UNLOCKED();
@@ -762,7 +781,7 @@ void complement_pos(struct vc_data *vc, int offset)
 	    old_offset < vc->vc_screenbuf_size) {
 		scr_writew(old, screenpos(vc, old_offset, true));
 		if (con_should_update(vc))
-			vc->vc_sw->con_putc(vc, old, oldy, oldx);
+			vc->vc_sw->con_putc(vc, (old_utf << 16) | old, oldy, oldx);
 		notify_update(vc);
 	}
 
@@ -772,14 +791,17 @@ void complement_pos(struct vc_data *vc, int offset)
 	    offset < vc->vc_screenbuf_size) {
 		unsigned short new;
 		unsigned short *p;
+		unsigned short *p_utf;
 		p = screenpos(vc, offset, true);
+		p_utf = screenpos_utf8(vc, offset, true);
 		old = scr_readw(p);
+		old_utf = scr_readw(p_utf);
 		new = old ^ vc->vc_complement_mask;
 		scr_writew(new, p);
 		if (con_should_update(vc)) {
 			oldx = (offset >> 1) % vc->vc_cols;
 			oldy = (offset >> 1) / vc->vc_cols;
-			vc->vc_sw->con_putc(vc, new, oldy, oldx);
+			vc->vc_sw->con_putc(vc, (old_utf << 16) | new, oldy, oldx);
 		}
 		notify_update(vc);
 	}
@@ -1093,7 +1115,7 @@ int vc_allocate(unsigned int currcons)	/* return 0 on success */
 	    vc->vc_screenbuf_size > KMALLOC_MAX_SIZE || !vc->vc_screenbuf_size)
 		goto err_free;
 	err = -ENOMEM;
-	vc->vc_screenbuf = kzalloc(vc->vc_screenbuf_size, GFP_KERNEL);
+	vc->vc_screenbuf = kzalloc(vc->vc_screenbuf_size * 2, GFP_KERNEL);
 	if (!vc->vc_screenbuf)
 		goto err_free;
 
@@ -1147,6 +1169,7 @@ static int vc_do_resize(struct tty_struct *tty, struct vc_data *vc,
 	unsigned long old_origin, new_origin, new_scr_end, rlth, rrem, err = 0;
 	unsigned long end;
 	unsigned int old_rows, old_row_size, first_copied_row;
+	unsigned int old_screen_size;
 	unsigned int new_cols, new_rows, new_row_size, new_screen_size;
 	unsigned int user;
 	unsigned short *oldscreen, *newscreen;
@@ -1190,7 +1213,7 @@ static int vc_do_resize(struct tty_struct *tty, struct vc_data *vc,
 
 	if (new_screen_size > KMALLOC_MAX_SIZE || !new_screen_size)
 		return -EINVAL;
-	newscreen = kzalloc(new_screen_size, GFP_USER);
+	newscreen = kzalloc(new_screen_size * 2, GFP_USER);
 	if (!newscreen)
 		return -ENOMEM;
 
@@ -1207,6 +1230,7 @@ static int vc_do_resize(struct tty_struct *tty, struct vc_data *vc,
 
 	old_rows = vc->vc_rows;
 	old_row_size = vc->vc_size_row;
+	old_screen_size = old_row_size * old_rows;
 
 	err = resize_screen(vc, new_cols, new_rows, user);
 	if (err) {
@@ -1255,15 +1279,23 @@ static int vc_do_resize(struct tty_struct *tty, struct vc_data *vc,
 	while (old_origin < end) {
 		scr_memcpyw((unsigned short *) new_origin,
 			    (unsigned short *) old_origin, rlth);
-		if (rrem)
+		scr_memcpyw((unsigned short *) new_origin + (new_screen_size >> 1),
+			    (unsigned short *) old_origin + (old_screen_size >> 1), rlth);
+		if (rrem) {
 			scr_memsetw((void *)(new_origin + rlth),
 				    vc->vc_video_erase_char, rrem);
+			scr_memsetw((void *)(new_origin + rlth + (new_screen_size)),
+				    vc->vc_video_erase_char, rrem);
+		}
 		old_origin += old_row_size;
 		new_origin += new_row_size;
 	}
-	if (new_scr_end > new_origin)
+	if (new_scr_end > new_origin) {
 		scr_memsetw((void *)new_origin, vc->vc_video_erase_char,
 			    new_scr_end - new_origin);
+		scr_memsetw((void *)new_origin + (new_screen_size), vc->vc_video_erase_char,
+			    new_scr_end - new_origin);
+	}
 	oldscreen = vc->vc_screenbuf;
 	vc->vc_screenbuf = newscreen;
 	vc->vc_screenbuf_size = new_screen_size;
@@ -2545,10 +2577,431 @@ static int ucs_cmp(const void *key, const void *elt)
 static int is_double_width(uint32_t ucs)
 {
 	static const struct interval double_width[] = {
-		{ 0x1100, 0x115F }, { 0x2329, 0x232A }, { 0x2E80, 0x303E },
-		{ 0x3040, 0xA4CF }, { 0xAC00, 0xD7A3 }, { 0xF900, 0xFAFF },
-		{ 0xFE10, 0xFE19 }, { 0xFE30, 0xFE6F }, { 0xFF00, 0xFF60 },
-		{ 0xFFE0, 0xFFE6 }, { 0x20000, 0x2FFFD }, { 0x30000, 0x3FFFD }
+		{ 0x34F, 0x34F },
+		{ 0x35C, 0x362 },
+		{ 0x378, 0x379 },
+		{ 0x380, 0x383 },
+		{ 0x38B, 0x38B },
+		{ 0x38D, 0x38D },
+		{ 0x3A2, 0x3A2 },
+		{ 0x488, 0x489 },
+		{ 0x52A, 0x52B },
+		{ 0x530, 0x530 },
+		{ 0x557, 0x558 },
+		{ 0x58B, 0x58E },
+		{ 0x590, 0x590 },
+		{ 0x5C8, 0x5CF },
+		{ 0x5EB, 0x5EE },
+		{ 0x5F5, 0x608 },
+		{ 0x60B, 0x60B },
+		{ 0x60E, 0x60F },
+		{ 0x611, 0x617 },
+		{ 0x61C, 0x61C },
+		{ 0x61E, 0x61E },
+		{ 0x656, 0x656 },
+		{ 0x6AA, 0x6AA },
+		{ 0x6D6, 0x6DA },
+		{ 0x6DC, 0x6DE },
+		{ 0x6E2, 0x6E3 },
+		{ 0x6E8, 0x6ED },
+		{ 0x700, 0x74F },
+		{ 0x790, 0x790 },
+		{ 0x79D, 0x79F },
+		{ 0x7B2, 0x7BF },
+		{ 0x7FB, 0x7FC },
+		{ 0x800, 0x86F },
+		{ 0x88F, 0x89B },
+		{ 0x8CC, 0x8CD },
+		{ 0x8D4, 0x8D4 },
+		{ 0x8DA, 0x8DF },
+		{ 0x900, 0xE00 },
+		{ 0xE3B, 0xE3E },
+		{ 0xE5B, 0xE80 },
+		{ 0xE83, 0xE83 },
+		{ 0xE85, 0xE85 },
+		{ 0xE8B, 0xE8B },
+		{ 0xEA4, 0xEA4 },
+		{ 0xEA6, 0xEA6 },
+		{ 0xEBE, 0xEBF },
+		{ 0xEC5, 0xEC5 },
+		{ 0xEC7, 0xEC7 },
+		{ 0xECF, 0xECF },
+		{ 0xEDA, 0xEDB },
+		{ 0xEE0, 0xEFF },
+		{ 0xF02, 0xF03 },
+		{ 0xF16, 0xF18 },
+		{ 0xF3A, 0xF3B },
+		{ 0xF48, 0xF48 },
+		{ 0xF6D, 0xF70 },
+		{ 0xF88, 0xF88 },
+		{ 0xF98, 0xF98 },
+		{ 0xFBD, 0xFBD },
+		{ 0xFC5, 0xFCD },
+		{ 0xFD0, 0xFD0 },
+		{ 0xFD5, 0x109F },
+		{ 0x10C6, 0x10C6 },
+		{ 0x10C8, 0x10CC },
+		{ 0x10CE, 0x10CF },
+		{ 0x1100, 0x1342 },
+		{ 0x1344, 0x1360 },
+		{ 0x1362, 0x138F },
+		{ 0x1395, 0x1395 },
+		{ 0x1397, 0x1398 },
+		{ 0x139A, 0x139F },
+		{ 0x13F6, 0x13F7 },
+		{ 0x13FE, 0x13FF },
+		{ 0x1401, 0x141D },
+		{ 0x142B, 0x1432 },
+		{ 0x143A, 0x1448 },
+		{ 0x144C, 0x1465 },
+		{ 0x1467, 0x146A },
+		{ 0x14C0, 0x14CF },
+		{ 0x14D3, 0x14E9 },
+		{ 0x150C, 0x1524 },
+		{ 0x1542, 0x1547 },
+		{ 0x1553, 0x155C },
+		{ 0x155E, 0x1569 },
+		{ 0x156B, 0x157A },
+		{ 0x157E, 0x1585 },
+		{ 0x158A, 0x1596 },
+		{ 0x159B, 0x159E },
+		{ 0x15A0, 0x15A5 },
+		{ 0x15B8, 0x15ED },
+		{ 0x15EF, 0x1600 },
+		{ 0x1602, 0x1645 },
+		{ 0x1648, 0x1659 },
+		{ 0x165B, 0x166C },
+		{ 0x166F, 0x1676 },
+		{ 0x1680, 0x169F },
+		{ 0x16E0, 0x16E0 },
+		{ 0x16E2, 0x16E2 },
+		{ 0x16F9, 0x1761 },
+		{ 0x1763, 0x17BA },
+		{ 0x17BC, 0x17CA },
+		{ 0x17CC, 0x17D5 },
+		{ 0x17D7, 0x17DB },
+		{ 0x17DD, 0x17EF },
+		{ 0x17FA, 0x18B3 },
+		{ 0x18B7, 0x18B7 },
+		{ 0x18BB, 0x18BD },
+		{ 0x18C0, 0x18C2 },
+		{ 0x18C6, 0x18D3 },
+		{ 0x18E0, 0x18E8 },
+		{ 0x18EA, 0x18EA },
+		{ 0x18EC, 0x18F2 },
+		{ 0x18F6, 0x194F },
+		{ 0x196E, 0x196F },
+		{ 0x1975, 0x1982 },
+		{ 0x1984, 0x198E },
+		{ 0x1990, 0x1990 },
+		{ 0x1992, 0x1999 },
+		{ 0x199B, 0x199D },
+		{ 0x199F, 0x19A0 },
+		{ 0x19A2, 0x19A2 },
+		{ 0x19A5, 0x19A6 },
+		{ 0x19A8, 0x19AF },
+		{ 0x19B4, 0x19B6 },
+		{ 0x19BB, 0x19C0 },
+		{ 0x19C2, 0x19C5 },
+		{ 0x19C7, 0x19C7 },
+		{ 0x19CA, 0x19CF },
+		{ 0x19D5, 0x19D5 },
+		{ 0x19D7, 0x19D7 },
+		{ 0x19DA, 0x1AAF },
+		{ 0x1ACF, 0x1C4F },
+		{ 0x1C89, 0x1C8F },
+		{ 0x1CBB, 0x1CBC },
+		{ 0x1CC0, 0x1CFF },
+		{ 0x1D7A, 0x1D7A },
+		{ 0x1DCD, 0x1DCD },
+		{ 0x1DFC, 0x1DFC },
+		{ 0x1F16, 0x1F17 },
+		{ 0x1F1E, 0x1F1F },
+		{ 0x1F46, 0x1F47 },
+		{ 0x1F4E, 0x1F4F },
+		{ 0x1F58, 0x1F58 },
+		{ 0x1F5A, 0x1F5A },
+		{ 0x1F5C, 0x1F5C },
+		{ 0x1F5E, 0x1F5E },
+		{ 0x1F7E, 0x1F7F },
+		{ 0x1FB5, 0x1FB5 },
+		{ 0x1FC5, 0x1FC5 },
+		{ 0x1FD4, 0x1FD5 },
+		{ 0x1FDC, 0x1FDC },
+		{ 0x1FF0, 0x1FF1 },
+		{ 0x1FF5, 0x1FF5 },
+		{ 0x1FFF, 0x1FFF },
+		{ 0x200B, 0x200F },
+		{ 0x2028, 0x202E },
+		{ 0x2057, 0x2057 },
+		{ 0x2060, 0x206F },
+		{ 0x2072, 0x2073 },
+		{ 0x208F, 0x208F },
+		{ 0x209D, 0x209F },
+		{ 0x20B9, 0x20B9 },
+		{ 0x20C1, 0x20CF },
+		{ 0x20DD, 0x20E0 },
+		{ 0x20E2, 0x20E4 },
+		{ 0x20E7, 0x20E7 },
+		{ 0x20EA, 0x20EA },
+		{ 0x20F1, 0x20FF },
+		{ 0x210E, 0x210F },
+		{ 0x212E, 0x212E },
+		{ 0x213A, 0x213D },
+		{ 0x213F, 0x2140 },
+		{ 0x2145, 0x2149 },
+		{ 0x214C, 0x214C },
+		{ 0x214F, 0x214F },
+		{ 0x2182, 0x2182 },
+		{ 0x2188, 0x2188 },
+		{ 0x218C, 0x218F },
+		{ 0x219C, 0x219D },
+		{ 0x21F4, 0x21F4 },
+		{ 0x21F9, 0x21FC },
+		{ 0x21FF, 0x21FF },
+		{ 0x22B6, 0x22B8 },
+		{ 0x22D8, 0x22D9 },
+		{ 0x22F2, 0x22F3 },
+		{ 0x22F5, 0x22F6 },
+		{ 0x22F9, 0x22FB },
+		{ 0x22FD, 0x22FD },
+		{ 0x22FF, 0x2300 },
+		{ 0x2316, 0x2316 },
+		{ 0x231A, 0x231B },
+		{ 0x2329, 0x232A },
+		{ 0x232C, 0x2335 },
+		{ 0x237B, 0x237E },
+		{ 0x2381, 0x2394 },
+		{ 0x2397, 0x239A },
+		{ 0x23B2, 0x23B6 },
+		{ 0x23C0, 0x23CA },
+		{ 0x23CD, 0x23CE },
+		{ 0x23D4, 0x23D9 },
+		{ 0x23DB, 0x23E7 },
+		{ 0x23E9, 0x2421 },
+		{ 0x2427, 0x243F },
+		{ 0x244B, 0x24FF },
+		{ 0x25EF, 0x25EF },
+		{ 0x25FD, 0x25FE },
+		{ 0x2603, 0x2603 },
+		{ 0x2605, 0x2606 },
+		{ 0x2610, 0x2612 },
+		{ 0x2614, 0x2619 },
+		{ 0x2622, 0x2624 },
+		{ 0x262B, 0x262C },
+		{ 0x262F, 0x2637 },
+		{ 0x2648, 0x2653 },
+		{ 0x2672, 0x268F },
+		{ 0x2692, 0x26A7 },
+		{ 0x26A9, 0x26AB },
+		{ 0x26AD, 0x26B1 },
+		{ 0x26B6, 0x26B6 },
+		{ 0x26BD, 0x26E1 },
+		{ 0x26E3, 0x2767 },
+		{ 0x2776, 0x27BF },
+		{ 0x27C1, 0x27C1 },
+		{ 0x27C3, 0x27C4 },
+		{ 0x27C8, 0x27C9 },
+		{ 0x27CB, 0x27D0 },
+		{ 0x27D2, 0x27D2 },
+		{ 0x27D5, 0x27DE },
+		{ 0x27E1, 0x27E5 },
+		{ 0x27F0, 0x27FF },
+		{ 0x2900, 0x2907 },
+		{ 0x290A, 0x2911 },
+		{ 0x2914, 0x2937 },
+		{ 0x293A, 0x2948 },
+		{ 0x294A, 0x294B },
+		{ 0x294E, 0x294E },
+		{ 0x2950, 0x2950 },
+		{ 0x2952, 0x2953 },
+		{ 0x2956, 0x2957 },
+		{ 0x295A, 0x295B },
+		{ 0x295E, 0x295F },
+		{ 0x2962, 0x297B },
+		{ 0x297E, 0x297F },
+		{ 0x2993, 0x2996 },
+		{ 0x299E, 0x299E },
+		{ 0x29A8, 0x29D0 },
+		{ 0x29DA, 0x29DB },
+		{ 0x29DF, 0x29E0 },
+		{ 0x29E2, 0x29EA },
+		{ 0x29EC, 0x29ED },
+		{ 0x29F4, 0x29F4 },
+		{ 0x29FE, 0x2A0A },
+		{ 0x2A0C, 0x2A0C },
+		{ 0x2A1D, 0x2A1D },
+		{ 0x2A20, 0x2A20 },
+		{ 0x2A2D, 0x2A2E },
+		{ 0x2A33, 0x2A3B },
+		{ 0x2A4E, 0x2A65 },
+		{ 0x2A68, 0x2A69 },
+		{ 0x2A74, 0x2A76 },
+		{ 0x2A78, 0x2A8A },
+		{ 0x2A8D, 0x2A8E },
+		{ 0x2A95, 0x2ABE },
+		{ 0x2ACD, 0x2AD2 },
+		{ 0x2AD7, 0x2ADD },
+		{ 0x2ADF, 0x2AED },
+		{ 0x2AF3, 0x2AF5 },
+		{ 0x2AF7, 0x2AFD },
+		{ 0x2B00, 0x2B05 },
+		{ 0x2B08, 0x2B0C },
+		{ 0x2B0E, 0x2B1C },
+		{ 0x2B1F, 0x2B24 },
+		{ 0x2B2C, 0x2B2D },
+		{ 0x2B30, 0x2B30 },
+		{ 0x2B32, 0x2B4D },
+		{ 0x2B50, 0x2BC8 },
+		{ 0x2BCA, 0x2BFE },
+		{ 0x2C0F, 0x2C0F },
+		{ 0x2C1F, 0x2C1F },
+		{ 0x2C27, 0x2C29 },
+		{ 0x2C3F, 0x2C3F },
+		{ 0x2C4F, 0x2C4F },
+		{ 0x2C57, 0x2C59 },
+		{ 0x2CE7, 0x2CE7 },
+		{ 0x2CEA, 0x2CEA },
+		{ 0x2CEF, 0x2CEF },
+		{ 0x2CF4, 0x2CF8 },
+		{ 0x2D05, 0x2D05 },
+		{ 0x2D07, 0x2D07 },
+		{ 0x2D0A, 0x2D0A },
+		{ 0x2D0D, 0x2D0D },
+		{ 0x2D10, 0x2D10 },
+		{ 0x2D13, 0x2D14 },
+		{ 0x2D1B, 0x2D1C },
+		{ 0x2D20, 0x2D20 },
+		{ 0x2D25, 0x2D26 },
+		{ 0x2D28, 0x2D2C },
+		{ 0x2D2E, 0x2D2F },
+		{ 0x2D48, 0x2D48 },
+		{ 0x2D68, 0x2D6E },
+		{ 0x2D71, 0x2D7E },
+		{ 0x2D80, 0x2DDF },
+		{ 0x2E0E, 0x2E11 },
+		{ 0x2E13, 0x2E15 },
+		{ 0x2E3A, 0x2E3B },
+		{ 0x2E43, 0x2E43 },
+		{ 0x2E50, 0x2E51 },
+		{ 0x2E5E, 0x303E },
+		{ 0x3040, 0xA4CF },
+		{ 0xA500, 0xA63F },
+		{ 0xA64C, 0xA64D },
+		{ 0xA65E, 0xA65E },
+		{ 0xA662, 0xA667 },
+		{ 0xA66C, 0xA66E },
+		{ 0xA670, 0xA670 },
+		{ 0xA672, 0xA672 },
+		{ 0xA684, 0xA685 },
+		{ 0xA698, 0xA699 },
+		{ 0xA6F8, 0xA6FF },
+		{ 0xA728, 0xA729 },
+		{ 0xA732, 0xA73D },
+		{ 0xA74E, 0xA74F },
+		{ 0xA758, 0xA759 },
+		{ 0xA771, 0xA777 },
+		{ 0xA7C2, 0xA7C3 },
+		{ 0xA7CB, 0xA7CF },
+		{ 0xA7D2, 0xA7D2 },
+		{ 0xA7D4, 0xA7D4 },
+		{ 0xA7DA, 0xA7F1 },
+		{ 0xA7FF, 0xA827 },
+		{ 0xA82A, 0xAB2F },
+		{ 0xAB6C, 0xAB6F },
+		{ 0xABC0, 0xD7FF },
+		{ 0xF900, 0xFAFF },
+		{ 0xFB07, 0xFB12 },
+		{ 0xFB18, 0xFB1C },
+		{ 0xFB21, 0xFB28 },
+		{ 0xFB37, 0xFB37 },
+		{ 0xFB3D, 0xFB3D },
+		{ 0xFB3F, 0xFB3F },
+		{ 0xFB42, 0xFB42 },
+		{ 0xFB45, 0xFB45 },
+		{ 0xFBC3, 0xFBD2 },
+		{ 0xFC1F, 0xFC1F },
+		{ 0xFC21, 0xFC21 },
+		{ 0xFC25, 0xFC25 },
+		{ 0xFC3D, 0xFC3E },
+		{ 0xFCAD, 0xFCAF },
+		{ 0xFCB1, 0xFCB7 },
+		{ 0xFCE7, 0xFCEA },
+		{ 0xFCFB, 0xFCFE },
+		{ 0xFD17, 0xFD20 },
+		{ 0xFD2D, 0xFD32 },
+		{ 0xFD34, 0xFD39 },
+		{ 0xFD3E, 0xFE1F },
+		{ 0xFE30, 0xFE6F },
+		{ 0xFE75, 0xFE75 },
+		{ 0xFEFD, 0xFF60 },
+		{ 0xFFBF, 0xFFC1 },
+		{ 0xFFC8, 0xFFC9 },
+		{ 0xFFD0, 0xFFD1 },
+		{ 0xFFD8, 0xFFD9 },
+		{ 0xFFDD, 0xFFE7 },
+		{ 0x16FE0, 0x16FE4 },
+		{ 0x16FF0, 0x16FF1 },
+		{ 0x17000, 0x187F7 },
+		{ 0x18800, 0x18CD5 },
+		{ 0x18D00, 0x18D08 },
+		{ 0x1AFF0, 0x1AFF3 },
+		{ 0x1AFF5, 0x1AFFB },
+		{ 0x1AFFD, 0x1AFFE },
+		{ 0x1B000, 0x1B122 },
+		{ 0x1B132, 0x1B132 },
+		{ 0x1B150, 0x1B152 },
+		{ 0x1B155, 0x1B155 },
+		{ 0x1B164, 0x1B167 },
+		{ 0x1B170, 0x1B2FB },
+		{ 0x1F004, 0x1F004 },
+		{ 0x1F0CF, 0x1F0CF },
+		{ 0x1F18E, 0x1F18E },
+		{ 0x1F191, 0x1F19A },
+		{ 0x1F200, 0x1F202 },
+		{ 0x1F210, 0x1F23B },
+		{ 0x1F240, 0x1F248 },
+		{ 0x1F250, 0x1F251 },
+		{ 0x1F260, 0x1F265 },
+		{ 0x1F300, 0x1F320 },
+		{ 0x1F32D, 0x1F335 },
+		{ 0x1F337, 0x1F37C },
+		{ 0x1F37E, 0x1F393 },
+		{ 0x1F3A0, 0x1F3CA },
+		{ 0x1F3CF, 0x1F3D3 },
+		{ 0x1F3E0, 0x1F3F0 },
+		{ 0x1F3F4, 0x1F3F4 },
+		{ 0x1F3F8, 0x1F43E },
+		{ 0x1F440, 0x1F440 },
+		{ 0x1F442, 0x1F4FC },
+		{ 0x1F4FF, 0x1F53D },
+		{ 0x1F54B, 0x1F54E },
+		{ 0x1F550, 0x1F567 },
+		{ 0x1F57A, 0x1F57A },
+		{ 0x1F595, 0x1F596 },
+		{ 0x1F5A4, 0x1F5A4 },
+		{ 0x1F5FB, 0x1F64F },
+		{ 0x1F680, 0x1F6C5 },
+		{ 0x1F6CC, 0x1F6CC },
+		{ 0x1F6D0, 0x1F6D2 },
+		{ 0x1F6D5, 0x1F6D7 },
+		{ 0x1F6DC, 0x1F6DF },
+		{ 0x1F6EB, 0x1F6EC },
+		{ 0x1F6F4, 0x1F6FC },
+		{ 0x1F7E0, 0x1F7EB },
+		{ 0x1F7F0, 0x1F7F0 },
+		{ 0x1F90C, 0x1F93A },
+		{ 0x1F93C, 0x1F945 },
+		{ 0x1F947, 0x1F9FF },
+		{ 0x1FA70, 0x1FA7C },
+		{ 0x1FA80, 0x1FA88 },
+		{ 0x1FA90, 0x1FABD },
+		{ 0x1FABF, 0x1FAC5 },
+		{ 0x1FACE, 0x1FADB },
+		{ 0x1FAE0, 0x1FAE8 },
+		{ 0x1FAF0, 0x1FAF8 },
+		{ 0x20000, 0x2FFFD },
+		{ 0x30000, 0x3FFFD }
 	};
 	if (ucs < double_width[0].first ||
 	    ucs > double_width[ARRAY_SIZE(double_width) - 1].last)
@@ -2778,6 +3231,8 @@ static int vc_con_write_normal(struct vc_data *vc, int tc, int c,
 			 * end up with having question marks only.
 			 */
 			tc = c;
+		} else if (c > 0xff) {
+			tc = 0xff;
 		} else {
 			/*
 			 * Display U+FFFD. If it's not found, display an inverse
@@ -2796,7 +3251,11 @@ static int vc_con_write_normal(struct vc_data *vc, int tc, int c,
 		}
 	}
 
-	next_c = c;
+	next_c = (c <= 0xffff) ? c : 0xfffd;
+	if (width == 2 && !vc->vc_need_wrap && vc->state.x == vc->vc_cols - 1) {
+		vc->vc_need_wrap = vc->vc_decawm;
+		draw->to = vc->vc_pos + 2;
+	}
 	while (1) {
 		if (vc->vc_need_wrap || vc->vc_decim)
 			con_flush(vc, draw);
@@ -2814,6 +3273,7 @@ static int vc_con_write_normal(struct vc_data *vc, int tc, int c,
 		tc |= (vc_attr << 8) & ~himask;
 
 		scr_writew(tc, (u16 *)vc->vc_pos);
+		scr_writew(next_c, (u16 *)vc->vc_pos + (vc->vc_screenbuf_size >> 1));
 
 		if (con_should_update(vc) && draw->x < 0) {
 			draw->x = vc->state.x;
@@ -2830,6 +3290,9 @@ static int vc_con_write_normal(struct vc_data *vc, int tc, int c,
 		if (!--width)
 			break;
 
+		tc = 0xfe;
+		continue;
+
 		/* A space is printed in the second column */
 		tc = conv_uni_to_pc(vc, ' ');
 		if (tc < 0)
@@ -2880,6 +3343,8 @@ static int do_con_write(struct tty_struct *tty, const u8 *buf, int count)
 	if (con_is_fg(vc))
 		hide_cursor(vc);
 
+	vc->vc_utf = 1;
+	vc->vc_disp_ctrl = 0;
 	param.vc = vc;
 
 	while (!tty->flow.stopped && count) {
@@ -3467,7 +3932,7 @@ static int __init con_init(void)
 		tty_port_init(&vc->port);
 		visual_init(vc, currcons, 1);
 		/* Assuming vc->vc_{cols,rows,screenbuf_size} are sane here. */
-		vc->vc_screenbuf = kzalloc(vc->vc_screenbuf_size, GFP_NOWAIT);
+		vc->vc_screenbuf = kzalloc(vc->vc_screenbuf_size * 2, GFP_NOWAIT);
 		vc_init(vc, currcons || !vc->vc_sw->con_save_screen);
 	}
 	currcons = fg_console = 0;
@@ -4684,7 +5149,10 @@ u16 screen_glyph(const struct vc_data *vc, int offset)
 {
 	u16 w = scr_readw(screenpos(vc, offset, true));
 	u16 c = w & 0xff;
+	u16 c_utf = scr_readw(screenpos_utf8(vc, offset, true));
 
+	if ((c == 0xff || c == 0xfe) && c_utf)
+		return c_utf;
 	if (w & vc->vc_hi_font_mask)
 		c |= 0x100;
 	return c;
diff --git a/drivers/video/fbdev/core/bitblit.c b/drivers/video/fbdev/core/bitblit.c
index 8587c9d..599ab37 100644
--- a/drivers/video/fbdev/core/bitblit.c
+++ b/drivers/video/fbdev/core/bitblit.c
@@ -16,6 +16,7 @@
 #include <linux/fb.h>
 #include <linux/vt_kern.h>
 #include <linux/console.h>
+#include <linux/font.h>
 #include <asm/types.h>
 #include "fbcon.h"
 
@@ -43,6 +44,51 @@ static void update_attr(u8 *dst, u8 *src, int attribute,
 	}
 }
 
+u16 utf8_pos(struct vc_data *vc, const u16 *s)
+{
+	unsigned long p = (unsigned long) s;
+
+	if (p >= vc->vc_origin && p < vc->vc_scr_end)
+		return scr_readw((u16 *) (p + vc->vc_screenbuf_size));
+	else
+		return scr_readw(s + 1);
+}
+
+u8 *font_bits(struct vc_data *vc, const u16 *s, u32 cellsize, u16 charmask,
+	struct fbcon_ops *ops)
+{
+	u8 *src;
+	u16 c_utf;
+	u32 cellsize_utf = (cellsize < 64) ? 16 : 64;
+	void *fontdata;
+	char *fontname = (cellsize < 64) ? "CJK16x16" : "CJK32x32";
+	const struct font_desc *font;
+
+	fontdata = ops ? ops->fontbuffer : vc->vc_font.data;
+	src = fontdata + (scr_readw(s) & charmask) * cellsize;
+	if ((scr_readw(s) & charmask) != 0xff && (scr_readw(s) & charmask) != 0xfe)
+		return src;
+
+	/* assume current font not support unicode */
+	if (vc->vc_font.charcount < 65536) {
+		if (ops)
+			fontdata = ops->fontbuffer_utf;
+		else {
+			font = find_font(fontname);
+			fontdata = (font && font->data) ? (void *) font->data : NULL;
+		}
+	}
+	if (fontdata) {
+		c_utf = utf8_pos(vc, s);
+		if ((scr_readw(s) & charmask) == 0xff)
+			src = fontdata + (c_utf * cellsize_utf * 2);
+		else
+			src = fontdata + (c_utf * cellsize_utf * 2 + cellsize_utf);
+	}
+
+	return src;
+}
+
 static void bit_bmove(struct vc_data *vc, struct fb_info *info, int sy,
 		      int sx, int dy, int dx, int height, int width)
 {
@@ -84,8 +130,7 @@ static inline void bit_putcs_aligned(struct vc_data *vc, struct fb_info *info,
 	u8 *src;
 
 	while (cnt--) {
-		src = vc->vc_font.data + (scr_readw(s++)&
-					  charmask)*cellsize;
+		src = font_bits(vc, s++, cellsize, charmask, NULL);
 
 		if (attr) {
 			update_attr(buf, src, attr, vc);
@@ -119,8 +164,7 @@ static inline void bit_putcs_unaligned(struct vc_data *vc,
 	u8 *src;
 
 	while (cnt--) {
-		src = vc->vc_font.data + (scr_readw(s++)&
-					  charmask)*cellsize;
+		src = font_bits(vc, s++, cellsize, charmask, NULL);
 
 		if (attr) {
 			update_attr(buf, src, attr, vc);
@@ -252,7 +296,7 @@ static void bit_cursor(struct vc_data *vc, struct fb_info *info, int mode,
 
  	c = scr_readw((u16 *) vc->vc_pos);
 	attribute = get_attribute(info, c);
-	src = vc->vc_font.data + ((c & charmask) * (w * vc->vc_font.height));
+	src = font_bits(vc, (u16 *) vc->vc_pos, (w * vc->vc_font.height), charmask, NULL);
 
 	if (ops->cursor_state.image.data != src ||
 	    ops->cursor_reset) {
diff --git a/drivers/video/fbdev/core/fbcon.c b/drivers/video/fbdev/core/fbcon.c
index f157a5a..90f335d 100644
--- a/drivers/video/fbdev/core/fbcon.c
+++ b/drivers/video/fbdev/core/fbcon.c
@@ -1050,7 +1050,7 @@ static void fbcon_init(struct vc_data *vc, int init)
 
 	vc->vc_can_do_color = (fb_get_color_depth(&info->var, &info->fix)!=1);
 	vc->vc_complement_mask = vc->vc_can_do_color ? 0x7700 : 0x0800;
-	if (vc->vc_font.charcount == 256) {
+	if (vc->vc_font.charcount != 512) {
 		vc->vc_hi_font_mask = 0;
 	} else {
 		vc->vc_hi_font_mask = 0x100;
@@ -1286,10 +1286,11 @@ static void fbcon_putcs(struct vc_data *vc, const unsigned short *s,
 
 static void fbcon_putc(struct vc_data *vc, int c, int ypos, int xpos)
 {
-	unsigned short chr;
+	unsigned short sc[2];
 
-	scr_writew(c, &chr);
-	fbcon_putcs(vc, &chr, 1, ypos, xpos);
+	sc[0] = (unsigned short) c;
+	sc[1] = (unsigned short) (c >> 16);
+	fbcon_putcs(vc, sc, 1, ypos, xpos);
 }
 
 static void fbcon_clear_margins(struct vc_data *vc, int bottom_only)
@@ -1371,7 +1372,7 @@ static void fbcon_set_disp(struct fb_info *info, struct fb_var_screeninfo *var,
 	ops->var = info->var;
 	vc->vc_can_do_color = (fb_get_color_depth(&info->var, &info->fix)!=1);
 	vc->vc_complement_mask = vc->vc_can_do_color ? 0x7700 : 0x0800;
-	if (vc->vc_font.charcount == 256) {
+	if (vc->vc_font.charcount != 512) {
 		vc->vc_hi_font_mask = 0;
 	} else {
 		vc->vc_hi_font_mask = 0x100;
@@ -1594,6 +1595,8 @@ static void fbcon_redraw_blit(struct vc_data *vc, struct fb_info *info,
 			}
 
 			scr_writew(c, d);
+			scr_writew(scr_readw(s + (vc->vc_screenbuf_size >> 1)),
+				d + (vc->vc_screenbuf_size >> 1));
 			console_conditional_schedule();
 			s++;
 			d++;
@@ -1615,6 +1618,7 @@ static void fbcon_redraw_blit(struct vc_data *vc, struct fb_info *info,
 
 static void fbcon_redraw(struct vc_data *vc, int line, int count, int offset)
 {
+	u16 charmask = vc->vc_hi_font_mask ? 0x1ff : 0xff;
 	unsigned short *d = (unsigned short *)
 	    (vc->vc_origin + vc->vc_size_row * line);
 	unsigned short *s = d + offset;
@@ -1637,18 +1641,24 @@ static void fbcon_redraw(struct vc_data *vc, int line, int count, int offset)
 					start = s;
 				}
 			}
-			if (c == scr_readw(d)) {
-				if (s > start) {
-					fbcon_putcs(vc, start, s - start,
-						     line, x);
-					x += s - start + 1;
-					start = s + 1;
-				} else {
-					x++;
-					start++;
+			if (((scr_readw(s) & charmask) == 0xff || (scr_readw(s) & charmask) == 0xfe)
+				&& scr_readw(s + (vc->vc_screenbuf_size >> 1))) {
+			} else {
+				if (c == scr_readw(d)) {
+					if (s > start) {
+						fbcon_putcs(vc, start, s - start,
+							     line, x);
+						x += s - start + 1;
+						start = s + 1;
+					} else {
+						x++;
+						start++;
+					}
 				}
 			}
 			scr_writew(c, d);
+			scr_writew(scr_readw(s + (vc->vc_screenbuf_size >> 1)),
+				d + (vc->vc_screenbuf_size >> 1));
 			console_conditional_schedule();
 			s++;
 			d++;
@@ -2140,7 +2150,7 @@ static int fbcon_switch(struct vc_data *vc)
 	vc->vc_can_do_color = (fb_get_color_depth(&info->var, &info->fix)!=1);
 	vc->vc_complement_mask = vc->vc_can_do_color ? 0x7700 : 0x0800;
 
-	if (vc->vc_font.charcount > 256)
+	if (vc->vc_font.charcount == 512)
 		vc->vc_complement_mask <<= 1;
 
 	updatescrollmode(p, info, vc);
@@ -2596,6 +2606,11 @@ static void fbcon_set_palette(struct vc_data *vc, const unsigned char *table)
 
 static u16 *fbcon_screen_pos(const struct vc_data *vc, int offset)
 {
+	if (offset < 0) {
+		offset = -offset - 1;
+		return (u16 *) (vc->vc_origin + offset + (vc->vc_screenbuf_size));
+	}
+
 	return (u16 *) (vc->vc_origin + offset);
 }
 
diff --git a/drivers/video/fbdev/core/fbcon.h b/drivers/video/fbdev/core/fbcon.h
index 0eaf54a..1e38d92 100644
--- a/drivers/video/fbdev/core/fbcon.h
+++ b/drivers/video/fbdev/core/fbcon.h
@@ -82,10 +82,12 @@ struct fbcon_ops {
 	int    cur_rotate;
 	char  *cursor_data;
 	u8    *fontbuffer;
+	u8    *fontbuffer_utf;
 	u8    *fontdata;
 	u8    *cursor_src;
 	u32    cursor_size;
 	u32    fd_size;
+	u32    fd_size_utf;
 };
     /*
      *  Attribute Decoding
diff --git a/drivers/video/fbdev/core/fbcon_ccw.c b/drivers/video/fbdev/core/fbcon_ccw.c
index 2789ace..ec68dbc 100644
--- a/drivers/video/fbdev/core/fbcon_ccw.c
+++ b/drivers/video/fbdev/core/fbcon_ccw.c
@@ -18,6 +18,8 @@
 #include "fbcon.h"
 #include "fbcon_rotate.h"
 
+extern u8 *font_bits(struct vc_data *vc, const u16 *s, u32 cellsize,
+		u16 charmask, struct fbcon_ops *ops);
 /*
  * Rotation 270 degrees
  */
@@ -106,7 +108,7 @@ static inline void ccw_putcs_aligned(struct vc_data *vc, struct fb_info *info,
 	u8 *src;
 
 	while (cnt--) {
-		src = ops->fontbuffer + (scr_readw(s--) & charmask)*cellsize;
+		src = font_bits(vc, s--, cellsize, charmask, ops);
 
 		if (attr) {
 			ccw_update_attr(buf, src, attr, vc);
@@ -238,7 +240,7 @@ static void ccw_cursor(struct vc_data *vc, struct fb_info *info, int mode,
 
  	c = scr_readw((u16 *) vc->vc_pos);
 	attribute = get_attribute(info, c);
-	src = ops->fontbuffer + ((c & charmask) * (w * vc->vc_font.width));
+	src = font_bits(vc, (u16 *) vc->vc_pos, (w * vc->vc_font.width), charmask, ops);
 
 	if (ops->cursor_state.image.data != src ||
 	    ops->cursor_reset) {
diff --git a/drivers/video/fbdev/core/fbcon_cw.c b/drivers/video/fbdev/core/fbcon_cw.c
index 86a254c..565cda9 100644
--- a/drivers/video/fbdev/core/fbcon_cw.c
+++ b/drivers/video/fbdev/core/fbcon_cw.c
@@ -18,6 +18,8 @@
 #include "fbcon.h"
 #include "fbcon_rotate.h"
 
+extern u8 *font_bits(struct vc_data *vc, const u16 *s, u32 cellsize,
+		u16 charmask, struct fbcon_ops *ops);
 /*
  * Rotation 90 degrees
  */
@@ -91,7 +93,7 @@ static inline void cw_putcs_aligned(struct vc_data *vc, struct fb_info *info,
 	u8 *src;
 
 	while (cnt--) {
-		src = ops->fontbuffer + (scr_readw(s++) & charmask)*cellsize;
+		src = font_bits(vc, s++, cellsize, charmask, ops);
 
 		if (attr) {
 			cw_update_attr(buf, src, attr, vc);
@@ -221,7 +223,7 @@ static void cw_cursor(struct vc_data *vc, struct fb_info *info, int mode,
 
  	c = scr_readw((u16 *) vc->vc_pos);
 	attribute = get_attribute(info, c);
-	src = ops->fontbuffer + ((c & charmask) * (w * vc->vc_font.width));
+	src = font_bits(vc, (u16 *) vc->vc_pos, (w * vc->vc_font.width), charmask, ops);
 
 	if (ops->cursor_state.image.data != src ||
 	    ops->cursor_reset) {
diff --git a/drivers/video/fbdev/core/fbcon_rotate.c b/drivers/video/fbdev/core/fbcon_rotate.c
index ec3c883..d549b08 100644
--- a/drivers/video/fbdev/core/fbcon_rotate.c
+++ b/drivers/video/fbdev/core/fbcon_rotate.c
@@ -14,10 +14,74 @@
 #include <linux/fb.h>
 #include <linux/vt_kern.h>
 #include <linux/console.h>
+#include <linux/font.h>
 #include <asm/types.h>
 #include "fbcon.h"
 #include "fbcon_rotate.h"
 
+static int fbcon_rotate_font_utf(struct fb_info *info, struct vc_data *vc)
+{
+	struct fbcon_ops *ops = info->fbcon_par;
+	int len, err = 0;
+	int s_cellsize, d_cellsize, i;
+	const u8 *src;
+	u8 *dst;
+
+	int cellsize = ((vc->vc_font.width + 7)/8) * vc->vc_font.height;
+	char *fontname = (cellsize < 64) ? "CJK16x16" : "CJK32x32";
+	const struct font_desc *font = find_font(fontname);
+
+	if (!font || !font->data)
+		return err;
+
+	src = font->data;
+	len = font->charcount;
+	s_cellsize = ((font->width + 7)/8) * font->height;
+	d_cellsize = s_cellsize;
+
+	if (ops->fd_size_utf < d_cellsize * len) {
+		dst = kvmalloc_array(len, d_cellsize, GFP_KERNEL | __GFP_RETRY_MAYFAIL);
+
+		if (dst == NULL) {
+			err = -ENOMEM;
+			return err;
+		}
+
+		ops->fd_size_utf = d_cellsize * len;
+		kvfree(ops->fontbuffer_utf);
+		ops->fontbuffer_utf = dst;
+	}
+
+	dst = ops->fontbuffer_utf;
+	memset(dst, 0, ops->fd_size_utf);
+
+	switch (ops->rotate) {
+	case FB_ROTATE_UD:
+		for (i = len; i--; ) {
+			rotate_ud(src, dst, font->width, font->height);
+			src += s_cellsize;
+			dst += d_cellsize;
+		}
+		break;
+	case FB_ROTATE_CW:
+		for (i = len; i--; ) {
+			rotate_cw(src, dst, font->width, font->height);
+			src += s_cellsize;
+			dst += d_cellsize;
+		}
+		break;
+	case FB_ROTATE_CCW:
+		for (i = len; i--; ) {
+			rotate_ccw(src, dst, font->width, font->height);
+			src += s_cellsize;
+			dst += d_cellsize;
+		}
+		break;
+	}
+
+	return err;
+}
+
 static int fbcon_rotate_font(struct fb_info *info, struct vc_data *vc)
 {
 	struct fbcon_ops *ops = info->fbcon_par;
@@ -46,7 +110,7 @@ static int fbcon_rotate_font(struct fb_info *info, struct vc_data *vc)
 		info->fbops->fb_sync(info);
 
 	if (ops->fd_size < d_cellsize * len) {
-		dst = kmalloc_array(len, d_cellsize, GFP_KERNEL);
+		dst = kvmalloc_array(len, d_cellsize, GFP_KERNEL | __GFP_RETRY_MAYFAIL);
 
 		if (dst == NULL) {
 			err = -ENOMEM;
@@ -54,7 +118,7 @@ static int fbcon_rotate_font(struct fb_info *info, struct vc_data *vc)
 		}
 
 		ops->fd_size = d_cellsize * len;
-		kfree(ops->fontbuffer);
+		kvfree(ops->fontbuffer);
 		ops->fontbuffer = dst;
 	}
 
@@ -89,6 +153,9 @@ static int fbcon_rotate_font(struct fb_info *info, struct vc_data *vc)
 		break;
 	}
 
+	if (ops->p->userfont)
+		fbcon_rotate_font_utf(info, vc);
+
 finished:
 	return err;
 }
diff --git a/drivers/video/fbdev/core/fbcon_ud.c b/drivers/video/fbdev/core/fbcon_ud.c
index 23bc045..6e7eaa5 100644
--- a/drivers/video/fbdev/core/fbcon_ud.c
+++ b/drivers/video/fbdev/core/fbcon_ud.c
@@ -18,6 +18,8 @@
 #include "fbcon.h"
 #include "fbcon_rotate.h"
 
+extern u8 *font_bits(struct vc_data *vc, const u16 *s, u32 cellsize,
+		u16 charmask, struct fbcon_ops *ops);
 /*
  * Rotation 180 degrees
  */
@@ -93,7 +95,7 @@ static inline void ud_putcs_aligned(struct vc_data *vc, struct fb_info *info,
 	u8 *src;
 
 	while (cnt--) {
-		src = ops->fontbuffer + (scr_readw(s--) & charmask)*cellsize;
+		src = font_bits(vc, s--, cellsize, charmask, ops);
 
 		if (attr) {
 			ud_update_attr(buf, src, attr, vc);
@@ -128,7 +130,7 @@ static inline void ud_putcs_unaligned(struct vc_data *vc,
 	u8 *src;
 
 	while (cnt--) {
-		src = ops->fontbuffer + (scr_readw(s--) & charmask)*cellsize;
+		src = font_bits(vc, s--, cellsize, charmask, ops);
 
 		if (attr) {
 			ud_update_attr(buf, src, attr, vc);
@@ -269,7 +271,7 @@ static void ud_cursor(struct vc_data *vc, struct fb_info *info, int mode,
 
  	c = scr_readw((u16 *) vc->vc_pos);
 	attribute = get_attribute(info, c);
-	src = ops->fontbuffer + ((c & charmask) * (w * vc->vc_font.height));
+	src = font_bits(vc, (u16 *) vc->vc_pos, (w * vc->vc_font.height), charmask, ops);
 
 	if (ops->cursor_state.image.data != src ||
 	    ops->cursor_reset) {
diff --git a/include/linux/font.h b/include/linux/font.h
index abf1442..9b19cae 100644
--- a/include/linux/font.h
+++ b/include/linux/font.h
@@ -35,6 +35,8 @@ struct font_desc {
 #define FONT6x10_IDX	10
 #define TER16x32_IDX	11
 #define FONT6x8_IDX	12
+#define CJK16x16_IDX	13
+#define CJK32x32_IDX	14
 
 extern const struct font_desc	font_vga_8x8,
 			font_vga_8x16,
@@ -48,7 +50,9 @@ extern const struct font_desc	font_vga_8x8,
 			font_mini_4x6,
 			font_6x10,
 			font_ter_16x32,
-			font_6x8;
+			font_6x8,
+			font_cjk_16x16,
+			font_cjk_32x32;
 
 /* Find a font with a specific name */
 
diff --git a/lib/fonts/Kconfig b/lib/fonts/Kconfig
index c035fde..f6fd619 100644
--- a/lib/fonts/Kconfig
+++ b/lib/fonts/Kconfig
@@ -125,6 +125,26 @@ config FONT_6x8
 	help
 	  This font is useful for small displays (OLED).
 
+config FONT_CJK_16x16
+	bool "CJK 16x16 font" if FONTS
+	depends on FRAMEBUFFER_CONSOLE && VT_CONSOLE
+	select CONSOLE_TRANSLATIONS
+	default y if !SPARC
+	help
+	  This is a high resolution console font that covers Unicode Basic
+	  Multilingual Plane (BMP), mostly is CJK font. If you want basic Unicode
+	  support on the VT console, say Y.
+
+config FONT_CJK_32x32
+	bool "CJK 32x32 font" if FONTS
+	depends on FRAMEBUFFER_CONSOLE && VT_CONSOLE
+	select CONSOLE_TRANSLATIONS
+	default y if !SPARC
+	help
+	  This is a more higher resolution console font that covers Unicode Basic
+	  Multilingual Plane (BMP), mostly is CJK font. If you want basic Unicode
+	  support on the VT console for a high res monitor, say Y.
+
 config FONT_AUTOSELECT
 	def_bool y
 	depends on !FONT_8x8
@@ -139,6 +159,8 @@ config FONT_AUTOSELECT
 	depends on !FONT_10x18
 	depends on !FONT_TER16x32
 	depends on !FONT_6x8
+	depends on !FONT_CJK_16x16
+	depends on !FONT_CJK_32x32
 	select FONT_8x16
 
 endif # FONT_SUPPORT
diff --git a/lib/fonts/Makefile b/lib/fonts/Makefile
index e16f684..3e1091d 100644
--- a/lib/fonts/Makefile
+++ b/lib/fonts/Makefile
@@ -16,6 +16,8 @@ font-objs-$(CONFIG_FONT_MINI_4x6)  += font_mini_4x6.o
 font-objs-$(CONFIG_FONT_6x10)      += font_6x10.o
 font-objs-$(CONFIG_FONT_TER16x32)  += font_ter16x32.o
 font-objs-$(CONFIG_FONT_6x8)       += font_6x8.o
+font-objs-$(CONFIG_FONT_CJK_16x16) += font_cjk_16x16.o
+font-objs-$(CONFIG_FONT_CJK_32x32) += font_cjk_32x32.o
 
 font-objs += $(font-objs-y)
 
diff --git a/lib/fonts/font_cjk_16x16.c b/lib/fonts/font_cjk_16x16.c
new file mode 100644
index 0000000..a0c56bd
--- /dev/null
+++ b/lib/fonts/font_cjk_16x16.c
@@ -0,0 +1,27 @@
+// SPDX-License-Identifier: GPL-2.0
+/***************************************************************/
+/*                                                             */
+/* Font file modified from                                     */
+/* http://blog.chinaunix.net/u/13265/showart.php?id=1008020    */
+/* microcaicai@gmail modifiy it to use in-kernel font solution */
+/*                                                             */
+/***************************************************************/
+
+#include <linux/font.h>
+
+#define FONTDATAMAX (65536 * 32)
+
+static const struct font_data fontdata_cjk_16x16 = {
+	{ 0, 0, FONTDATAMAX, 0 }, {
+	#include "font_cjk_16x16.h"
+}};
+
+const struct font_desc font_cjk_16x16 = {
+	.idx	= CJK16x16_IDX,
+	.name	= "CJK16x16",
+	.width	= 8, /* make cursor appear 8 dot width */
+	.height	= 16,
+	.charcount	= 65536 * 2,
+	.data	= fontdata_cjk_16x16.data,
+	.pref	= 20, /* make it big enough to be chosen */
+};
diff --git a/lib/fonts/font_cjk_32x32.c b/lib/fonts/font_cjk_32x32.c
new file mode 100644
index 0000000..88ba3f2
--- /dev/null
+++ b/lib/fonts/font_cjk_32x32.c
@@ -0,0 +1,27 @@
+// SPDX-License-Identifier: GPL-2.0
+/***************************************************************/
+/*                                                             */
+/* Font file modified from                                     */
+/* http://blog.chinaunix.net/u/13265/showart.php?id=1008020    */
+/* microcaicai@gmail modifiy it to use in-kernel font solution */
+/*                                                             */
+/***************************************************************/
+
+#include <linux/font.h>
+
+#define FONTDATAMAX (65536 * 128)
+
+static const struct font_data fontdata_cjk_32x32 = {
+	{ 0, 0, FONTDATAMAX, 0 }, {
+	#include "font_cjk_32x32.h"
+}};
+
+const struct font_desc font_cjk_32x32 = {
+	.idx	= CJK32x32_IDX,
+	.name	= "CJK32x32",
+	.width	= 16,
+	.height	= 32,
+	.charcount	= 65536 * 2,
+	.data	= fontdata_cjk_32x32.data,
+	.pref	= -1,
+};
diff --git a/lib/fonts/font_cjk_32x32.h b/lib/fonts/font_cjk_32x32.h
new file mode 100644
index 0000000..e69de29
diff --git a/lib/fonts/fonts.c b/lib/fonts/fonts.c
index 9738664..16b414a 100644
--- a/lib/fonts/fonts.c
+++ b/lib/fonts/fonts.c
@@ -60,6 +60,12 @@ static const struct font_desc *fonts[] = {
 #ifdef CONFIG_FONT_6x8
 	&font_6x8,
 #endif
+#ifdef CONFIG_FONT_CJK_16x16
+	&font_cjk_16x16,
+#endif
+#ifdef CONFIG_FONT_CJK_32x32
+	&font_cjk_32x32,
+#endif
 };
 
 #define num_fonts ARRAY_SIZE(fonts)
